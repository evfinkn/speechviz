diff --git a/node_modules/peaks.js/.DS_Store b/node_modules/peaks.js/.DS_Store
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/peaks.js/dist/peaks.esm.js b/node_modules/peaks.js/dist/peaks.esm.js
index 70847f9..18ec394 100644
--- a/node_modules/peaks.js/dist/peaks.esm.js
+++ b/node_modules/peaks.js/dist/peaks.esm.js
@@ -1134,7 +1134,7 @@ function WaveformPoints(peaks) {
 
 
 WaveformPoints.prototype._getNextPointId = function () {
-  return 'peaks.point.' + this._pointIdCounter++;
+  return 'point.' + this._pointIdCounter++;
 };
 /**
  * Adds a new point object.
@@ -1589,7 +1589,7 @@ function WaveformSegments(peaks) {
 
 
 WaveformSegments.prototype._getNextSegmentId = function () {
-  return 'peaks.segment.' + this._segmentIdCounter++;
+  return 'segment.' + this._segmentIdCounter;
 };
 
 var colors = ['#001f3f', // navy
@@ -1657,6 +1657,7 @@ WaveformSegments.prototype._createSegment = function (options) {
   if (isNullOrUndefined(segmentOptions.id)) {
     segmentOptions.id = this._getNextSegmentId();
   }
+  this._segmentIdCounter++;
 
   if (isNullOrUndefined(segmentOptions.color)) {
     segmentOptions.color = this._getSegmentColor();
@@ -1735,12 +1736,30 @@ WaveformSegments.prototype.add = function
 () {
   var self = this;
   var arrayArgs = Array.isArray(arguments[0]);
+  var overwrite = arguments[1]?.overwrite;
   var segments = arrayArgs ? arguments[0] : Array.prototype.slice.call(arguments);
   segments = segments.map(function (segmentOptions) {
-    var segment = self._createSegment(segmentOptions);
+    var segment;
+
+    if (segmentOptions instanceof Segment) {
+      segment = segmentOptions;
+    }
+    else {
+      segment = self._createSegment(segmentOptions);
+    }
 
     if (objectHasProperty(self._segmentsById, segment.id)) {
-      throw new Error('peaks.segments.add(): duplicate id');
+      if (overwrite) {
+        self.removeById(segment.id);
+      }
+      else {
+        console.log(`Duplicate id: ${segment.id}`)
+        console.log("\nTrying to add:")
+        console.log(segment)
+        console.log("\nCurrent segment with id:")
+        console.log(self._segmentsById[segment.id])
+        throw new Error('peaks.segments.add(): duplicate id');
+      }
     }
 
     return segment;
@@ -2190,9 +2209,10 @@ function getAllPropertiesFrom(adapter) {
   var obj = adapter;
 
   while (obj) {
-    Object.getOwnPropertyNames(obj).forEach(function (p) {
+    Object.getOwnPropertyNames(obj).forEach(function(p) {
       allProperties.push(p);
     });
+
     obj = Object.getPrototypeOf(obj);
   }
 
@@ -2212,6 +2232,18 @@ function validateAdapter(adapter) {
     }
   });
 }
+
+function isValidSegment(segment) {
+  return segment && 
+    isValidTime(segment.startTime) &&
+    isValidTime(segment.endTime);
+}
+
+function* segmentIterator(segments, loop = false) {
+  for (let i = 0; (i < segments.length) || loop; i++) {
+    yield segments[i % segments.length];
+  }
+}
 /**
  * A wrapper for interfacing with an external player API.
  *
@@ -2222,26 +2254,24 @@ function validateAdapter(adapter) {
  * @param {Adapter} adapter The player adapter.
  */
 
-
 function Player(peaks, adapter) {
   this._peaks = peaks;
-  this._playingSegment = false;
+  this._playing = false;
+  this._segments = null;
   this._segment = null;
-  this._loop = false;
   this._playSegmentTimerCallback = this._playSegmentTimerCallback.bind(this);
   validateAdapter(adapter);
   this._adapter = adapter;
 }
 
-Player.prototype.init = function () {
+Player.prototype.init = function() {
   return this._adapter.init(this._peaks);
 };
 /**
  * Cleans up the player object.
  */
 
-
-Player.prototype.destroy = function () {
+Player.prototype.destroy = function() {
   this._adapter.destroy();
 };
 /**
@@ -2249,16 +2279,14 @@ Player.prototype.destroy = function () {
  * @returns {Promise}
  */
 
-
-Player.prototype.play = function () {
+Player.prototype.play = function() {
   return this._adapter.play();
 };
 /**
  * Pauses playback.
  */
 
-
-Player.prototype.pause = function () {
+Player.prototype.pause = function() {
   this._adapter.pause();
 };
 /**
@@ -2266,16 +2294,14 @@ Player.prototype.pause = function () {
  * otherwise.
  */
 
-
-Player.prototype.isPlaying = function () {
+Player.prototype.isPlaying = function() {
   return this._adapter.isPlaying();
 };
 /**
  * @returns {boolean} <code>true</code> if seeking
  */
 
-
-Player.prototype.isSeeking = function () {
+Player.prototype.isSeeking = function() {
   return this._adapter.isSeeking();
 };
 /**
@@ -2284,8 +2310,7 @@ Player.prototype.isSeeking = function () {
  * @returns {Number}
  */
 
-
-Player.prototype.getCurrentTime = function () {
+Player.prototype.getCurrentTime = function() {
   return this._adapter.getCurrentTime();
 };
 /**
@@ -2294,8 +2319,7 @@ Player.prototype.getCurrentTime = function () {
  * @returns {Number}
  */
 
-
-Player.prototype.getDuration = function () {
+Player.prototype.getDuration = function() {
   return this._adapter.getDuration();
 };
 /**
@@ -2304,8 +2328,7 @@ Player.prototype.getDuration = function () {
  * @param {Number} time The time position, in seconds.
  */
 
-
-Player.prototype.seek = function (time) {
+Player.prototype.seek = function(time) {
   if (!isValidTime(time)) {
     this._peaks._logger('peaks.player.seek(): parameter must be a valid time, in seconds');
 
@@ -2321,53 +2344,71 @@ Player.prototype.seek = function (time) {
  * @param {Boolean} loop If true, playback is looped.
  */
 
+Player.prototype.playSegment = function(segment, loop) {
+  if (!isValidSegment(segment)) {
+    return Promise.reject(new Error('peaks.player.playSegment(): parameter must be a segment object'));
+  }
+
+  this.playSegments([segment], loop);
+};
 
-Player.prototype.playSegment = function (segment, loop) {
+Player.prototype.playSegments = function(segments, loop) {
   var self = this;
 
-  if (!segment || !isValidTime(segment.startTime) || !isValidTime(segment.endTime)) {
-    return Promise.reject(new Error('peaks.player.playSegment(): parameter must be a segment object'));
+  if (!Array.isArray(segments) || !segments.every(isValidSegment)) {
+    return Promise.reject(
+      new Error('peakers.player.playSegments(): parameter must be an array of segment objects')
+    );
+  }
+  if (segments.length == 0) {
+    return;
   }
 
-  self._segment = segment;
-  self._loop = loop; // Set audio time to segment start time
+  self._segments = segmentIterator(segments, loop);
+  self._segment = self._segments.next().value;
 
-  self.seek(segment.startTime);
+  // Set audio time to segment start time
+  self.seek(self._segment.startTime);
 
-  self._peaks.once('player.playing', function () {
-    if (!self._playingSegment) {
-      self._playingSegment = true; // We need to use requestAnimationFrame here as the timeupdate event
-      // doesn't fire often enough.
+  self._peaks.once('player.playing', function() {
+    if (!self._playing) {
+      self._playing = true;
 
+      // We need to use requestAnimationFrame here as the timeupdate event
+      // doesn't fire often enough.
       window.requestAnimationFrame(self._playSegmentTimerCallback);
     }
-  }); // Start playing audio
-
+  });
 
+  // Start playing audio
   return self.play();
-};
+}
 
-Player.prototype._playSegmentTimerCallback = function () {
+Player.prototype._playSegmentTimerCallback = function() {
   if (!this.isPlaying()) {
-    this._playingSegment = false;
+    this._playing = false;
     return;
-  } else if (this.getCurrentTime() >= this._segment.endTime) {
-    if (this._loop) {
-      this.seek(this._segment.startTime);
-    } else {
-      this.pause();
+  }
+  else if (this.getCurrentTime() >= this._segment.endTime) {
+    var next = this._segments.next();
 
+    if (next.done) {
+      this.pause();
       this._peaks.emit('player.ended');
-
-      this._playingSegment = false;
+      this._playing = false;
+      this._segments.return();
       return;
     }
+    else {
+      this._segment = next.value;
+      this.seek(this._segment.startTime);
+    }
   }
 
   window.requestAnimationFrame(this._playSegmentTimerCallback);
 };
 
-Player.prototype._setSource = function (options) {
+Player.prototype._setSource = function(options) {
   return this._adapter.setSource(options);
 };
 
diff --git a/node_modules/peaks.js/dist/peaks.js b/node_modules/peaks.js/dist/peaks.js
index 5206c82..2a73f0b 100644
--- a/node_modules/peaks.js/dist/peaks.js
+++ b/node_modules/peaks.js/dist/peaks.js
@@ -1417,7 +1417,7 @@
 
 
   WaveformPoints.prototype._getNextPointId = function () {
-    return 'peaks.point.' + this._pointIdCounter++;
+    return 'point.' + this._pointIdCounter++;
   };
   /**
    * Adds a new point object.
@@ -1872,7 +1872,7 @@
 
 
   WaveformSegments.prototype._getNextSegmentId = function () {
-    return 'peaks.segment.' + this._segmentIdCounter++;
+    return 'segment.' + this._segmentIdCounter;
   };
 
   var colors = ['#001f3f', // navy
@@ -1940,6 +1940,7 @@
     if (isNullOrUndefined(segmentOptions.id)) {
       segmentOptions.id = this._getNextSegmentId();
     }
+    this._segmentIdCounter++;
 
     if (isNullOrUndefined(segmentOptions.color)) {
       segmentOptions.color = this._getSegmentColor();
@@ -2018,12 +2019,30 @@
   () {
     var self = this;
     var arrayArgs = Array.isArray(arguments[0]);
+    var overwrite = arguments[1]?.overwrite;
     var segments = arrayArgs ? arguments[0] : Array.prototype.slice.call(arguments);
     segments = segments.map(function (segmentOptions) {
-      var segment = self._createSegment(segmentOptions);
+      var segment;
+
+      if (segmentOptions instanceof Segment) {
+        segment = segmentOptions;
+      }
+      else {
+        segment = self._createSegment(segmentOptions);
+      }
 
       if (objectHasProperty(self._segmentsById, segment.id)) {
-        throw new Error('peaks.segments.add(): duplicate id');
+        if (overwrite) {
+          self.removeById(segment.id);
+        }
+        else {
+          console.log(`Duplicate id: ${segment.id}`)
+          console.log("\nTrying to add:")
+          console.log(segment)
+          console.log("\nCurrent segment with id:")
+          console.log(self._segmentsById[segment.id])
+          throw new Error('peaks.segments.add(): duplicate id');
+        }
       }
 
       return segment;
@@ -2473,9 +2492,10 @@
     var obj = adapter;
 
     while (obj) {
-      Object.getOwnPropertyNames(obj).forEach(function (p) {
+      Object.getOwnPropertyNames(obj).forEach(function(p) {
         allProperties.push(p);
       });
+
       obj = Object.getPrototypeOf(obj);
     }
 
@@ -2495,6 +2515,18 @@
       }
     });
   }
+
+  function isValidSegment(segment) {
+    return segment && 
+      isValidTime(segment.startTime) &&
+      isValidTime(segment.endTime);
+  }
+
+  function* segmentIterator(segments, loop = false) {
+    for (let i = 0; (i < segments.length) || loop; i++) {
+      yield segments[i % segments.length];
+    }
+  }
   /**
    * A wrapper for interfacing with an external player API.
    *
@@ -2505,26 +2537,24 @@
    * @param {Adapter} adapter The player adapter.
    */
 
-
   function Player(peaks, adapter) {
     this._peaks = peaks;
-    this._playingSegment = false;
+    this._playing = false;
+    this._segments = null;
     this._segment = null;
-    this._loop = false;
     this._playSegmentTimerCallback = this._playSegmentTimerCallback.bind(this);
     validateAdapter(adapter);
     this._adapter = adapter;
   }
 
-  Player.prototype.init = function () {
+  Player.prototype.init = function() {
     return this._adapter.init(this._peaks);
   };
   /**
    * Cleans up the player object.
    */
 
-
-  Player.prototype.destroy = function () {
+  Player.prototype.destroy = function() {
     this._adapter.destroy();
   };
   /**
@@ -2532,16 +2562,14 @@
    * @returns {Promise}
    */
 
-
-  Player.prototype.play = function () {
+  Player.prototype.play = function() {
     return this._adapter.play();
   };
   /**
    * Pauses playback.
    */
 
-
-  Player.prototype.pause = function () {
+  Player.prototype.pause = function() {
     this._adapter.pause();
   };
   /**
@@ -2549,16 +2577,14 @@
    * otherwise.
    */
 
-
-  Player.prototype.isPlaying = function () {
+  Player.prototype.isPlaying = function() {
     return this._adapter.isPlaying();
   };
   /**
    * @returns {boolean} <code>true</code> if seeking
    */
 
-
-  Player.prototype.isSeeking = function () {
+  Player.prototype.isSeeking = function() {
     return this._adapter.isSeeking();
   };
   /**
@@ -2567,8 +2593,7 @@
    * @returns {Number}
    */
 
-
-  Player.prototype.getCurrentTime = function () {
+  Player.prototype.getCurrentTime = function() {
     return this._adapter.getCurrentTime();
   };
   /**
@@ -2577,8 +2602,7 @@
    * @returns {Number}
    */
 
-
-  Player.prototype.getDuration = function () {
+  Player.prototype.getDuration = function() {
     return this._adapter.getDuration();
   };
   /**
@@ -2587,8 +2611,7 @@
    * @param {Number} time The time position, in seconds.
    */
 
-
-  Player.prototype.seek = function (time) {
+  Player.prototype.seek = function(time) {
     if (!isValidTime(time)) {
       this._peaks._logger('peaks.player.seek(): parameter must be a valid time, in seconds');
 
@@ -2604,53 +2627,71 @@
    * @param {Boolean} loop If true, playback is looped.
    */
 
+  Player.prototype.playSegment = function(segment, loop) {
+    if (!isValidSegment(segment)) {
+      return Promise.reject(
+        new Error('peaks.player.playSegment(): parameter must be a segment object')
+      );
+    }
+
+    this.playSegments([segment], loop);
+  };
 
-  Player.prototype.playSegment = function (segment, loop) {
+  Player.prototype.playSegments = function(segments, loop) {
     var self = this;
 
-    if (!segment || !isValidTime(segment.startTime) || !isValidTime(segment.endTime)) {
-      return Promise.reject(new Error('peaks.player.playSegment(): parameter must be a segment object'));
+    if (!Array.isArray(segments) || !segments.every(isValidSegment)) {
+      return Promise.reject(new Error('peakers.player.playSegments(): parameter must be an array of segment objects'));
+    }
+    if (segments.length == 0) {
+      return;
     }
 
-    self._segment = segment;
-    self._loop = loop; // Set audio time to segment start time
+    self._segments = segmentIterator(segments, loop);
+    self._segment = self._segments.next().value;
 
-    self.seek(segment.startTime);
+    // Set audio time to segment start time
+    self.seek(self._segment.startTime);
 
-    self._peaks.once('player.playing', function () {
-      if (!self._playingSegment) {
-        self._playingSegment = true; // We need to use requestAnimationFrame here as the timeupdate event
-        // doesn't fire often enough.
+    self._peaks.once('player.playing', function() {
+      if (!self._playing) {
+        self._playing = true;
 
+        // We need to use requestAnimationFrame here as the timeupdate event
+        // doesn't fire often enough.
         window.requestAnimationFrame(self._playSegmentTimerCallback);
       }
-    }); // Start playing audio
-
+    });
 
+    // Start playing audio
     return self.play();
-  };
+  }
 
-  Player.prototype._playSegmentTimerCallback = function () {
+  Player.prototype._playSegmentTimerCallback = function() {
     if (!this.isPlaying()) {
-      this._playingSegment = false;
+      this._playing = false;
       return;
-    } else if (this.getCurrentTime() >= this._segment.endTime) {
-      if (this._loop) {
-        this.seek(this._segment.startTime);
-      } else {
-        this.pause();
+    }
+    else if (this.getCurrentTime() >= this._segment.endTime) {
+      var next = this._segments.next();
 
+      if (next.done) {
+        this.pause();
         this._peaks.emit('player.ended');
-
-        this._playingSegment = false;
+        this._playing = false;
+        this._segments.return();
         return;
       }
+      else {
+        this._segment = next.value;
+        this.seek(this._segment.startTime);
+      }
     }
 
     window.requestAnimationFrame(this._playSegmentTimerCallback);
   };
 
-  Player.prototype._setSource = function (options) {
+  Player.prototype._setSource = function(options) {
     return this._adapter.setSource(options);
   };
 
